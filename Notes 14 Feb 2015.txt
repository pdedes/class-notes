___________

TWITTER Workshop
___________

	The App.js file is the initial setup of the application. It's good practice to modularize when possible, for example, move routes to a separate routes.js file

	Modulalrization:
		You can get information from a module, BUT if you want to give information to it, 'require' does not support that. The module needs to be turned into a function in order to get parameters passed to it, via functional programming.

		It's good practice to simplify app by pulling as much out of it as possible.

	When we first run the application, the stylesheets were off, this is because we had not explicitly made the public folder available to GET requests. We need to use...	
		app.use(express.static(__dirname + '/public'));

	One reason the URL scheme suggested (/users/:name/tweets/:id) is cardinality, one User may have multiple tweets, followers, or other resources etc.

	The Tweet ID can be tagged with a number via the ADD function in TweetBank. Just add ID to the object and use data.length as an indicator for which number is available next.

	Getting the individual tweet id was solved using ParseInt, the problem being that the comparison between "ID" from the URL and the Data store was between unequal types (Int & String). You need to use a combination of console.log and upstream/downstream thinking to find the issues.

	Always test your mental model in the code by using the console to see if data is getting delivered (in the right format) to the destination that you expect. For example, for 'req.params.text' becomes a problem for post requests - we need to use a body parser to properly read these inputs.
		FORM DATA >> (see source in Chrome Dev Tools). The name and text of the tweet is being passed in an ugly format, A tweet that has the following data:
		name: Pete
		tweet: Hello there.

			May be passed to the server as...

			name&Pete%20&tweet&Hello%20there (an example). 

		We need a way to peel this apart for the useful information. We use Body Parser middleware to handle these inputs.

	SOCKETS

		HTTP does not support updating clients...
			1. One client cannot notify the other client the update has happened
			2. One client needs to be constantly polling the server for new data via http to mimic a realtime feel

		Sockets allow the browser to keep open a persistent connection with the server. It's a separate protocol.

		You cannot initialize a connection via Socket, but you can handle all of the information afterwards doing it. Generally speaking, not all requests are made with Sockets. Sockets are great when you need to communicate across other clients changes that have happened.

		$npm install socket.io --save

			var server = app.listen(3000);
			var io = socketio.listen(server);

			^^The socketio listen event piggy-backs on the established http connection port.

		The timing and scoping of initializing IO in the app/index.js files can be very important to prevent errors.

			IO is not defined in the index file, so we need to be able to pass "IO" as a variable to the Router function we have created...

		Appending the tweet to the DOM - You want to find the correct container
			1. Find the container
			2. Find the children
			3. Find the last child

		A few ways to circumnavigate the pain of maintaining the HTML are below. There are tools to help with this messy maintenance issue.
			1. Build a side SWIG template for the individual tweets
			2. Angular...
				>Receives JSON from the server
				>Angular uses client-side JS to built the template on the spot...


		Module exportation of a function is useful when you want to send it information upon requiring it.


___________

DATABASES
___________

	What's in a name?

	What's in a datapoint?

	We'll talk about SQL & NoSQL databases
		>Relational databases have been around for almost 50 years
		>NoSQL have excellent new features, but Relational is still the standard

	Databases that can't be loaded into RAM start to change your interactions with it. They are very hard to scale, therefore are usually done last.

	DBs need special attention when scaling. How do you replicate a new post across all of the databases at nearly simultaneous time?

	Oracle was the first company that brought a product to market from relational db theory.

	The DBMS abstracts away data storage for the business or non-technical person. It is a layer between the schema and the application. It knows where to find the data you're looking for.

		Devs only need to know the DBMS language to find and alter data

	SQL is a language for talking to the DBMS

		--> You can specify what answers the query should return, but not how the query is executed or where and how the data is stored.

	Databases also handle file/locking multiple access for you.

	Vocabulary;
		-Tables
		-Attributes (Columns)
		-Instances (Rows)
		-Duplicate rows are not allowed
		-Schema - the data structure
			>Shouldn't change very often but they do
			>SQL is bad at this
			>NoSQL is good at changing on the fly

	Example: We have two tables: Students, Schools
		>Introduce a third table "Enrollment" which relates those two tables

	The whole point of web applications, to get store and retrieve data...

	SQL Commands --> CRUD

		INSERT > Insert a new row
		SELECT > Get data from a DB
		UPDATE > Update existing row
		DELETE > Delete rows from a table
		CREATE

	A relation table does not replicate all of the data, it tries to minimize the amount of duplicative data by utilizing the table ID #s.

	Example...

		SELECT 	*
		FROM 	Student
		WHERE 	age > 12

	A relationship between two tables can be used to query for the data you want. You do this using a JOIN.

	Advantage of relationship tables is that they can help preventing the duplication of data, It's similar to DRY programming in a sense.

	JOIN gives you a temporary view of this 'terrible' duplicative view in memory. You can then perform your query, and the join will be destroyed following that.

	Creating a JOIN happens in two steps:
		1. Join the first table with the relational table based on a shared column
		2. Join the second table with the one from step 1, based on a shared column (this will likely cause the duplication)
		---
		Next: Query the newly JOINed table





















